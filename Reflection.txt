1. A time limitation of my current minimax algorithm is that it involves the evaluation of every node/state in a game tree, which takes a significant amount of time if the initial number of pieces in the game is very large. A large number of pieces in the game also creates a space limitation because the entire game tree must be stored to be evaluated. 

2. It is unlikely that your bot will win every possible game of SimpleNim because whoever goes first, given that both players are playing optimally, wins; if the other player goes first and is playing optimally, they will win! 

3. To give the best move for a game of AntiNim where you win if you take the last piece, you would need to make some changes to base cases in the runGame() and minimax() functions. First, in the runGame() function, you would need to intialize the boolean as false and then line 14 and 5 would need to change to if (pieces ==0), Xwins = true. This is changing the base case so that if there are 0 pieces left and Player X just went, then player x wins (not loses). You would also need to alter the base case in minimax(). Line 30  would need to change to "return -1" so the program can indicate that if a state is 0 and it's player x's turn, that is bad. Likewise, line 34 would need to change to "return 1" so the program can indicate that if a state is 0 and its player y's turn, that is bad for player y (but good for player x). 

4. One game that I expect the minimax algorithm to not work well on is the memory game (card matching game). My current algorithm would not work well on this game because this game does not involve simple alternating turns. The rule of this game is if you find a matching pair, you get to go again. The minimax algorithm expects alternating turns each time, and also is not currently capable to keep a count of how many matching pairs each player has, and, thus, would not work for the memory game.  